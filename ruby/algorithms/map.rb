#!/usr/bin/env ruby
require 'graph.rb'

mapA = %w[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          %----------------------------------------------%
          %----------------------------------------------%
          %----------------------------------------------%
          %----------------------------------------------%
          %---@------------------------------------------%
          %----------------------------------------------%
          %----------------------------------------------%
          %----------------------------------------------%
          %----------------------------------------------%
          %------------------------------------------X---%
          %----------------------------------------------%
          %----------------------------------------------%
          %----------------------------------------------%
          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]

mapB = %w[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          %---o---------o-------o--------o-------o-------%
          %ooo-----------ooooooo----------ooooooo--------%
          %---o---------o#######o--------o#######o---X---%
          %----o-------o#########o------o#########o------%
          %-----ooooooo###########oooooo###########oooooo%
          %----o-------o#########o######o#########o------%
          %---o---------o#######o########o#######o-------%
          %ooo-----------ooooooo##########ooooooo--------%
          %---o---------o#######o########o-------o-------%
          %----o-------o#########o######o---------o------%
          %-----@-ooooo###########oooooo-----------oooooo%
          %----o-------o#########o------o---------o------%
          %---o---------o#######o--------o-------o-------%
          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]

mapC = %w[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
          %----------------------------------------------%
          %-@-%%%%%---%%%%%%%%%%%%%%%%---%%%%%%%%%%%%%%%%%
          %---%----------------------%---%---------------%
          %---%---%%%%%%%%%%%%---%---%---%---%%%%%%%%%-X-%
          %---%---%--------------%---%---%---------------%
          %---%---%%%%%%%%---%---%---%---%---%%%%%%%%%%%%%
          %---%---%----------%---%---%---%---%-----------%
          %---%---%---%%%%%%%%---%---%---%---%---%%%%%---%
          %---%--------------%---%-------%---%-----------%
          %---%%%%%%%%%%%%---%---%%%%%%%%%---%%%%%%%%%---%
          %--------------%---%---------------------------%
          %---%%%%%%%%---%---%%%%%%%%%%%%%---%%%%%%%%%---%
          %------------------ooooooooooooooooooooooooo---%
          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]

mapD = %w[@^.^~****^*~~.~^~..~~~^~.^~.*~**.^^*^*^~..*^^..~^.
          *.*~*.~^^^~~.*~*.**.~~^*^**.^~*^^.*^...^..^.**.~^*
          ^^***~.*^*^..^**.~~~.~*.~^^~^~^.^~^*~**.~*^.^**.*.
          *~~.~^.~*~^~^^*^**.~.*^^*~~^^*~.^.*^^*^.^.~~^^^*~.
          *.^~^^.~^.^.^^*~^~~*^..^~^~~^.*^^..**.**~.~~^~*~**
          ^.^^~^.*~**.*~*^*~^*~~^.^.~.~^**~.^^^^*.~.~~~^^.^.
          *~~.*.^~~~^*.^*~~~*^.^**^*^.^.^~~***^^*^.~^^.^^.~.
          .~.*~~^*.**.~^^~**^.^.^~~~^.~.^~~^^.~^^.^^~.~.~.*^
          .^^^~~*~.^.~.*~.~~..~*~^.~**~..^****~.*~^~~*~**^~^
          ^^^*^^**...*.^^*^^^.*~*~^^~*~~.~****~~~~***.^^~~^~
          ..*^^^^^.^~.^~.^.^^~*~^*~**^*^.~~~*^.^^~**~*~.....
          **.^~~~^~*~****.**^~.^.*^^^~.^...~.**^^^^~^.~^~.~*
          ^*~.*.~*^.~.^^^^^*~.**~^.*^*.~~..^~~~*~*^.~~^*^*^^
          ~*^.^..**~**^*^~***^~~*^*.*~..~^^***^.*~.^*^^^^.~.
          *~^~^**^^*^^~^*~^^*~~~*^*~~~~*~^^^*~..~~~~~.*~^~*.
          ^.*.^*^**^^^~**.*.~^~~~^..~~~*~~^*~..^^.^~*.^~^~**
          .***^..*^~~~~^~.*^~~.*.~^.^^*.***^~^.*....~.^.*~^^
          ^^~~~~.**.*.^^*.^~~^....*~*^~*^^.^~~~^*.~^^^~**^~~
          ^~~*^*.~.*^^^*^.*..~*...~**^.^^~.^^.^..^.^**.^^..*
          ~^***~^.~.~^^^*~~~.*..^~^^.~^.~.**...~^~**~^~~**^~
          ~~~^~.^*.^*.~*.*~~^..~*^^~~**.*.*.~^^^..^.~^.*.^~~
          ^^~...^.*~.^^**~^~*..^~^~*....^.^^**~.*.^^*..~*~.*
          ^..^...~.~.*.~***~*~~*..~*~^^~~^~**^~~^*^^~*.~*^*^
          *^.**^~*****.~~~..~^~.*.^*~^.^^*^..*~^.^.^*.^.~^^*
          ~...~*^....*^.*^^*...^.~~..^.*~.*~.*^.^*^*^.****^~
          ^..~***^.*^~~.****.~*^.~.^~*.~^*^~^.****~..~*..*^~
          .~^~**~^^..~~~^..*~*.^**~..^^*.~.*..*~~*~.^~.~*~~.
          .***~..~**^.~.~.~*.~~**..^.^~..~*~~~~*.**~~^..^.^^
          ~.*.~^*^*~^.~*..*~^~~.*.*..*.*..^~.*~^^*.~^.^~^**^
          .*^~^^*.^*.~*...*~~~*.**.~...*.*^.^*.^*~*.^~^**^*.
          .~..*....~..~.***~..~^..~~^*^*^~^^~~**^.*~**^**^^*
          ^.*.~.^.**^*^.~^^*.~..*^~*^***.~**..^.~~*..^*^~*.~
          ^~~^~~*.~^^~~^**.^.^^^*^.*^^~~.^.*~^*^^..**..**..^
          ^.^*.*^..*.~~.^^***^.*~..~.**^*.~^...^^~*.~^~^..~~
          ~^^.^..*^^.**.~~^*~*^~*~^~~.~*.^~.~*^~*.*..^.^^*^*
          ^^.~*^~~*.~~*~.^..~*.^.~**.^*^.^~.**.~*.~...~~..*.
          .~..^.~.~.^*.~^*~.~.*^*~~*.^.******~*~~*^~~~^.~~*~
          ~.*..^^*^~*.~~.~.^~..~.~^^^.*~*.**~^*~*^*^^~..^~^^
          *.^*^**^*.^^*....**..~^^~.^*^.*~*^**^^..*.^^*^^^.~
          ^*^~^^*.~*~^*~^~~.*.^*^~*^^~.*~.*~.**.*~^~~.~*^~~*
          ~~**~*.^.*~..~~^^^~^^^.~***^*.^*~^*~^~*~**...~..~.
          *~**^~~.^.*.~^**~*^^.*^*.^~~*~~~*^.*..~~^*^.*^.^.*
          .*^~..*~.*^^^^^~~^^*.~*.~~~.***~^.*..~~******~~^*.
          .^^..^.^*^~^.~*...**~~~.**^*~~~*^***~^*^~^~~^^^*.*
          **.**~.**~.*.*^~~.~^.*^.~~*.^*.~.***~*^^..~*.~*^*^
          ~..^.****^.****~^~***..^^^^*^.~*^^*.~~.^**^*~^*.~~
          ^*~^.~*...^^.^~.^^..~^...**...^****^*~*~*^..~^*~.~
          ...^~^.~^^~~~~.*^~.^~***~~^^^.*^^.~.^*~*~**^***^~^
          .~~~~~^^.~~*^.~^^^**~^~.^~^~*..^*~^^*..*~^~**.*.^.
          ~^**.~**..*^~^^^.^*^~^~*^.~*~.^.**.^.^^.~**^~~^~^X]
          
class Map
  attr :tiles
  attr :graph
  attr :a
  attr :b
  
  @@cost = {'%' => ::ADT::Infinity,
            '#' => 1.25,
            '-' => 1.00,
            '@' => 1.00,
            'X' => 1.00,
            'o' => 0.25,
            
            # ruby quiz
            '~' => ::ADT::Infinity,
            '.' => 1.00,
            '*' => 2.00,
            '^' => 3.00}
  
  def initialize
    @tiles = []
    @graph = ADT::Graph.new
  end
  
  def draw
    puts @tiles.map{|row| row.join}.join("\n")
  end
  
  def inspect
    @graph.inspect
  end
  
  def read data, diag = false
    initialize
    
    data.size.times do |y|
      data[y].size.times do |x|
        type = data[y][x].chr
        
        case type
        when '@'
          @a = [x,y]
        when 'X'
          @b = [x,y]
        end
        
        # store tile object
        @tiles[y] = [] unless @tiles[y]
        @tiles[y][x] = tile = Tile.new(type, x, y)
        
        # connect to each neighbor
        if x > 0
          xcost = [ @@cost[tile.type], @@cost[@tiles[y][x-1].type] ].max
          @graph.connect tile, @tiles[y][x-1], xcost
        end
        
        if y > 0
          ycost = [ @@cost[tile.type], @@cost[@tiles[y-1][x].type] ].max
          
          # length of side (x or y motion) = 1
          @graph.connect tile, @tiles[y-1][x], ycost
        end
        
        if diag and y > 0 and x > 0
          # connect me to north-west tile, no corner cutting
          dcost = [ @@cost[@tiles[y-1][x-1].type], # move north west
                    ycost,                         # move north
                    xcost ].max                    # move west
          
          # length of hypotenuse = sqrt(2) =~ 1.4
          @graph.connect tile, @tiles[y-1][x-1], 1.4*dcost
        end
        
        if diag and y > 0 and @tiles[y-1].size-1 > x
          # connect me to north-east tile, no corner cutting
          dcost = [ @@cost[data[y][x+1].chr] || 0,  # move east
                    @@cost[@tiles[y-1][x+1].type],  # move north-east
                    ycost ].max                     # move north
          
          # length of hypotenuse = sqrt(2) =~ 1.4
          @graph.connect tile, @tiles[y-1][x+1], 1.4*dcost
        end
      end
    end
    
    self
  end
  
  def path start=@a, goal=@b
    start = @tiles[start.last][start.first]
    goal  = @tiles[goal.last][goal.first]
    
    # calculate cost from edge weight
    cost = lambda{|u,v| @graph.edge(u,v).value}
    
    # manhattan
    h = lambda{|v| 1.00 * ((v.x-goal.x).abs + (v.y-goal.y).abs)}
    
    # diagonal
    #h = lambda{|v| 1.5 * [(v.x-goal.x).abs, (v.y-goal.y).abs].max}
    
    # special diagonal
    #h = lambda do |v|
    #  diagonal = [(v.x-goal.x).abs, (v.y-goal.y).abs].min
    #  straight = (v.x-goal.x).abs + (v.y-goal.y).abs
    #  Math.sqrt(2.0)*diagonal + 1.0*(straight - 2*diagonal)
    #end
    
    # euclidean
    #h = lambda{|v| 0.75 * Math.sqrt((v.x-goal.x)**2 + (v.y-goal.y)**2)}
    
    # dijkstra
    #h = lambda {|v| 0}
    
    # cross product tie breaker
    t = lambda do |v|
      cross = ((v.x-goal.x)*(start.y-goal.y) -
              (start.x-goal.x)*(v.y-goal.y)).abs
      cross * 0.001 + h.call(v)
    end
    
    # scaler tie breaker
    #t = lambda{|v| 1.001 * h.call(v)}
    
    # no tie breaker
    #t = h
    
    path = @graph.astar(start, cost, t) {|x| x == goal}
    
    # mark each examined node with white space
    #path.each do |k, p|
    #  unless @tiles[k.y][k.x].type == '%'
    #    @tiles[k.y][k.x].type = ' '
    #  end
    #end
    
    # number of non-wall tiles
    total = @graph.nodes.select{|x| x.type != '%'}.size
    count = tcost = 0
    last  = goal
    
    # trace path with dots, calculate totals
    while p = path[p || goal]
      p.type = ' '
      count += 1
      tcost += cost.call(last, p)
      last   = p
    end
    
    # mark start and end nodes
    start.type = '@'
    goal.type  = 'X'
    
    draw
    
    puts "Examined #{path.size}/#{total} nodes "  <<
         ("(%d%%) " % [100*path.size.to_f/total]) <<
         "path length #{count}, cost #{tcost}"
    puts
  end
  
end

class Map::Tile
  attr :type, true
  attr :x
  attr :y
  
  def initialize type, x, y
    @type, @x, @y = type, x, y
  end
  
  def to_s
    @type
  end
  
  def inspect
    @type
  end
  
  def coord
    "(#{@x}, #{@y})"
  end
end

$maps = [mapA, mapB, mapC, mapD]

if $0 == __FILE__
  $m = Map.new
  
  $maps.each do |data|
    $m.read data, true
    $m.path
    puts
  end
end
