#!/usr/bin/env ruby
# $Hg: parse.rb 5852f75cb5be 2008-02-06 00:52 -0600 kputnam $

# TODO: allow for specifying time parsing format like
#  parse(str, "%YYYY-%mm-%dd")

  # multi word phrases
  #   half past four
  #   quarter till eight
  #   June the 8th
  #   the 8th of June
  #   three and a half hours ago

module NLTime

# Read individual tokens (generated by Tokenizer) and analyze them
# using regular expressions, apply tags from the 'winner' of several
# possible interpretations, determined by a scoring system
class Parser
  attr_reader :options
  
  class << self
    def parse(*args, &block)
      # add anchors
      args[-1] = Regexp.new("^#{args.last}$")
      
      (@parsers ||= []) << [args, block]
    end
    
    def parsers
      @parsers
    end
  end
  
  def initialize(options={})
    @options = { :mode => :us, :verbose => NLTime.debug? }.merge(options)
  end
  
  def parse(tokens)
    while (k ||= tokens.size) > 0
      token = tokens[k-1]
      if token.include?(NLTime::Entity) or token.include?(NLTime::Duration)
        next k -= 1
      end
      
      # possible interpretations of token
      possible = {}
      
      self.class.parsers.each do |args, block|
        regexp = args.last
        
        next unless catch(:fail) do
          args[0..-2].each do |tag|
            throw(:fail) unless token.include?(tag)
          end
          true
        end
        next unless res = token.word.match(regexp)
        
        object, score = block.call(res, self, token, tokens)
        (possible[score||0] ||= []) << object if object
        
        break if (score||0) > 0
      end
      
      unless possible.empty?
        # TODO: devise a tie-breaking method?
        best = possible.keys.max
        token.tag(*possible[best].first)
      end
      
      k -= 1
    end
    tokens
    
  end
  
#=begin
  parse(:numeric, /\d{4}/) do |m,p,t,tokens|
    begin
      [:year, 1]
    rescue ArgumentError
    end
  end
  
  # two digit number... *possibly* a year
  parse(:numeric, /\d{2}/) do |m,p,t,tokens|
    begin
      if t.before =~ /'$/
        year = NLTime::Entity::Year.convert(m.to_s.to_i)
        #NLTime::Entity::Year.new(year)
        [[:year, year], 1]
      end
    rescue ArgumentError
    end
  end
  
  # yyyy-nn-nn and yyyy-nn
  parse(:numeric, /(\d{4})([.\/-]?)(\d{1,2})(?:\2(\d{1,2}))?/) do |m,p,t,tokens|
    unless t.include?(:ordinal)
      y, sep, a, b = m.captures
      begin
        year  = NLTime::Entity::Year.new(y.to_i)
        month = NLTime::Entity::Month.new(a.to_i, year)
        tag   = b ? NLTime::Entity::Date.new(b.to_i, month) : month
      rescue ArgumentError
        begin
          # yyyy-dd-mm is very unlikely
          if b
            month = NLTime::Entity::Month.new(b.to_i, year)
            tag   = NLTime::Entity::Date.new(a.to_i, month)
          end
        rescue ArgumentError
        end
      end
    end
  end
  
  # nn-nn-yyyy or nn-nn-yy
  parse(:numeric, /(\d{1,2})([.\/-]?)(\d{1,2})\2(\d{4}|\d{2})/) do |m,p,t,tokens|
    case p.options[:mode]
    when :us: a, sep, b, y = m.captures
    else      b, sep, a, y = m.captures
    end
    begin
      year  = NLTime::Entity::Year.new(NLTime::Entity::Year.convert(y.to_i))
      month = NLTime::Entity::Month.new(a.to_i, year)
      tag   = NLTime::Entity::Date.new(b.to_i, month)
    rescue ArgumentError
      begin
        month = NLTime::Entity::Month.new(b.to_i, year)
        tag   = NLTime::Entity::Date.new(a.to_i, month)
      rescue ArgumentError
      end
    end
  end
  
  # nn-nnnn
  parse(:numeric, /(\d{1,2})([.\/-]?)(\d{4})/) do |m,p,t,tokens|
    prev = tokens[tokens.index(t)-1]
    month, sep, y = m.captures
    
    unless prev.include?(:month) and t.before == sep
      begin
        year = NLTime::Entity::Year.new(y.to_i)
        tag  = NLTime::Entity::Month.new(month.to_i, year)
      rescue ArgumentError
      end
    else
      # Jun-05-2000
      #     ^^^^^^^
    end
  end
  
  # offset +nnnn -nn:nn
  parse(:numeric, /([+-]\d{1,2})(?::?(\d{2}))/) do |m,p,t,tokens|
    hours, minutes = m.captures
    begin
      tag = NLTime::Duration::Offset.new(hours, minutes)
    rescue ArgumentError
    end
  end
  
  # nn:nn, nn:nn:nn, nn:nn:nn:nnnnn..
  parse(:numeric, /(\d{1,2})([:.]?)(\d{2})(?:\2(\d+(?:\2\d+)?))?/) do |m,p,t,tokens|
    hour, sep, minute, second = m.captures
    begin
      tag = NLTime::Duration::Time.new(hour, minute, second)
    rescue ArgumentError
    end
  end
  # nn:nn, nn:nn:nn, nn:nn:nn.nnnnn..
  parse(:numeric, /(\d{1,2})([:.]?)(\d{2})(?:\2(\d+(?:\.\d+)?))?/) do |m,p,t,tokens|
    hour, sep, minute, second = m.captures
    begin
      tag = NLTime::Duration::Time.new(hour, minute, second)
    rescue ArgumentError
    end
  end
  
  parse(:word, /midnight/i) do#|m,p,t,tokens|
    NLTime::Duration::Time.new(0, 0, 0)
  end
  
  parse(:word, /noon/i) do#|m,p,t,tokens|
    NLTime::Duration::Time.new(12, 0, 0)
  end
  
  parse(:word, /today/i) do#|m,p,t,tokens|
    NLTime.today
  end
  
  parse(:word, /yesterday/i) do#|m,p,t,tokens|
    NLTime.yesterday
  end
  
  parse(:word, /tomorrow/i) do#|m,p,t,tokens|
    NLTime.tomorrow
  end
  
  parse(:word, /before|preceeding|until|prior|ago/i) do#|t|
    [[:relation, :before], 0]
  end
  
  parse(:word, /after|from|since|following/i) do#|t|
    [[:relation, :after], 0]
  end
  
  parse(:word, /of|in|at|on|during|within/i) do#|t|
    [[:relation, :subset], 0]
  end
  
  parse(:word, /from|between|within|to|through/i) do#|t|
    [[:relation, :range], 0]
  end
  
  # TODO this should be parsed as multiword phrase: somewhere close to ..
  parse(:word, /approximately|somewhere|around|near|close|to/i) do#|t|
    [[:fuzzy], 0]
  end
  
  parse(:word, /^p\.?(m\.?)?$/i) do#|t|
    [[:meridiem, :pm], 0]
  end
  
  parse(:word, /^a\.?(m\.?)?$/i) do#|t|
    [[:meridiem, :am], 0]
  end
  
  parse(:word, /[a-z]{3,}/i) do |m,p,t,tokens|
    if m = NLTime::Entity::Month.name(t.word)
      [[:month, :single, m], 0]
    elsif m = NLTime::Entity::Month.name(t.word[/(.+?)(e|ie|y)s/, 1])
      [[:month, :plural, m], 0]
    end
  end
  
  parse(:word, /[a-z]{3,}/i) do |m,p,t,tokens|
    if day = NLTime::Duration::Day.name(t.word)
      [[day, :day, :single], 0]
    elsif day = NLTime::Duration::Day.name(t.word[/(.+?)(e|ie|y)s/, 1])
      [[day, :day, :plural], 0]
    end
  end
  
  parse(:word, /this|the|that|these|those/i) do#|t|
    [[:article, :single], 0]
  end
  
  parse(:word, /each|every|these|those/i) do#|t|
    [[:article, :plural], 0]
  end
  
  parse(:word, /next|upcoming|following/i) do#|t|
    [[:iterative, :forward], 0]
  end
  
  parse(:word, /last|past|prev(?:ious)?|preceeding/i) do#|t|
    [[:iterative, :backward], 0]
  end
  
  single = NLTime::Entity.constants.map{|c| c.to_s }
  parse(:word, Regexp.new(single.join('|'), true)) do#|t|
    [[:entity, :single], 0]
  end
  
  plural = single.map{|c| (c.gsub(/[^a]y$/, 'ie') << 's').gsub(/iums$/, 'ia') }
  parse(:word, Regexp.new(plural.join('|'), true)) do#|t|
    [[:entity, :plural], 0]
  end  
#=end
end

end
